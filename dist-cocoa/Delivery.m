/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"
#import "TBase.h"


#import "Delivery.h"

@implementation MDCourier

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithId: (int32_t) id name: (NSString *) name phone: (NSString *) phone gender: (int) gender
{
  self = [super init];
  __id = id;
  __id_isset = YES;
  __name = [name retain_stub];
  __name_isset = YES;
  __phone = [phone retain_stub];
  __phone_isset = YES;
  __gender = gender;
  __gender_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [decoder decodeInt32ForKey: @"id"];
    __id_isset = YES;
  }
  if ([decoder containsValueForKey: @"name"])
  {
    __name = [[decoder decodeObjectForKey: @"name"] retain_stub];
    __name_isset = YES;
  }
  if ([decoder containsValueForKey: @"phone"])
  {
    __phone = [[decoder decodeObjectForKey: @"phone"] retain_stub];
    __phone_isset = YES;
  }
  if ([decoder containsValueForKey: @"gender"])
  {
    __gender = [decoder decodeIntForKey: @"gender"];
    __gender_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeInt32: __id forKey: @"id"];
  }
  if (__name_isset)
  {
    [encoder encodeObject: __name forKey: @"name"];
  }
  if (__phone_isset)
  {
    [encoder encodeObject: __phone forKey: @"phone"];
  }
  if (__gender_isset)
  {
    [encoder encodeInt: __gender forKey: @"gender"];
  }
}

- (void) dealloc
{
  [__name release_stub];
  [__phone release_stub];
  [super dealloc_stub];
}

- (int32_t) id {
  return __id;
}

- (void) setId: (int32_t) id {
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  __id_isset = NO;
}

- (NSString *) name {
  return [[__name retain_stub] autorelease_stub];
}

- (void) setName: (NSString *) name {
  [name retain_stub];
  [__name release_stub];
  __name = name;
  __name_isset = YES;
}

- (BOOL) nameIsSet {
  return __name_isset;
}

- (void) unsetName {
  [__name release_stub];
  __name = nil;
  __name_isset = NO;
}

- (NSString *) phone {
  return [[__phone retain_stub] autorelease_stub];
}

- (void) setPhone: (NSString *) phone {
  [phone retain_stub];
  [__phone release_stub];
  __phone = phone;
  __phone_isset = YES;
}

- (BOOL) phoneIsSet {
  return __phone_isset;
}

- (void) unsetPhone {
  [__phone release_stub];
  __phone = nil;
  __phone_isset = NO;
}

- (int) gender {
  return __gender;
}

- (void) setGender: (int) gender {
  __gender = gender;
  __gender_isset = YES;
}

- (BOOL) genderIsSet {
  return __gender_isset;
}

- (void) unsetGender {
  __gender_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setName: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPhone: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setGender: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Courier"];
  if (__id_isset) {
    [outProtocol writeFieldBeginWithName: @"id" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __id];
    [outProtocol writeFieldEnd];
  }
  if (__name_isset) {
    if (__name != nil) {
      [outProtocol writeFieldBeginWithName: @"name" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __name];
      [outProtocol writeFieldEnd];
    }
  }
  if (__phone_isset) {
    if (__phone != nil) {
      [outProtocol writeFieldBeginWithName: @"phone" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __phone];
      [outProtocol writeFieldEnd];
    }
  }
  if (__gender_isset) {
    [outProtocol writeFieldBeginWithName: @"gender" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __gender];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
  if (!__id_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'id' is not set."];
  }
  if (!__name_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'name' is not set."];
  }
  if (!__phone_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'phone' is not set."];
  }
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDCourier("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"%i", __id];
  [ms appendString: @",name:"];
  [ms appendFormat: @"\"%@\"", __name];
  [ms appendString: @",phone:"];
  [ms appendFormat: @"\"%@\"", __phone];
  [ms appendString: @",gender:"];
  [ms appendFormat: @"%i", __gender];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation MDLatLng

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithLat: (double) lat lng: (double) lng
{
  self = [super init];
  __lat = lat;
  __lat_isset = YES;
  __lng = lng;
  __lng_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"lat"])
  {
    __lat = [decoder decodeDoubleForKey: @"lat"];
    __lat_isset = YES;
  }
  if ([decoder containsValueForKey: @"lng"])
  {
    __lng = [decoder decodeDoubleForKey: @"lng"];
    __lng_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__lat_isset)
  {
    [encoder encodeDouble: __lat forKey: @"lat"];
  }
  if (__lng_isset)
  {
    [encoder encodeDouble: __lng forKey: @"lng"];
  }
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (double) lat {
  return __lat;
}

- (void) setLat: (double) lat {
  __lat = lat;
  __lat_isset = YES;
}

- (BOOL) latIsSet {
  return __lat_isset;
}

- (void) unsetLat {
  __lat_isset = NO;
}

- (double) lng {
  return __lng;
}

- (void) setLng: (double) lng {
  __lng = lng;
  __lng_isset = YES;
}

- (BOOL) lngIsSet {
  return __lng_isset;
}

- (void) unsetLng {
  __lng_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_DOUBLE) {
          double fieldValue = [inProtocol readDouble];
          [self setLat: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_DOUBLE) {
          double fieldValue = [inProtocol readDouble];
          [self setLng: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"LatLng"];
  if (__lat_isset) {
    [outProtocol writeFieldBeginWithName: @"lat" type: TType_DOUBLE fieldID: 1];
    [outProtocol writeDouble: __lat];
    [outProtocol writeFieldEnd];
  }
  if (__lng_isset) {
    [outProtocol writeFieldBeginWithName: @"lng" type: TType_DOUBLE fieldID: 2];
    [outProtocol writeDouble: __lng];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
  if (!__lat_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'lat' is not set."];
  }
  if (!__lng_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'lng' is not set."];
  }
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDLatLng("];
  [ms appendString: @"lat:"];
  [ms appendFormat: @"%f", __lat];
  [ms appendString: @",lng:"];
  [ms appendFormat: @"%f", __lng];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation MDDelivery

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithId: (NSString *) id origin: (MDLatLng *) origin destination: (MDLatLng *) destination status: (int) status courier: (MDCourier *) courier createdAt: (MDTimestamp) createdAt
{
  self = [super init];
  __id = [id retain_stub];
  __id_isset = YES;
  __origin = [origin retain_stub];
  __origin_isset = YES;
  __destination = [destination retain_stub];
  __destination_isset = YES;
  __status = status;
  __status_isset = YES;
  __courier = [courier retain_stub];
  __courier_isset = YES;
  __createdAt = createdAt;
  __createdAt_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"id"])
  {
    __id = [[decoder decodeObjectForKey: @"id"] retain_stub];
    __id_isset = YES;
  }
  if ([decoder containsValueForKey: @"origin"])
  {
    __origin = [[decoder decodeObjectForKey: @"origin"] retain_stub];
    __origin_isset = YES;
  }
  if ([decoder containsValueForKey: @"destination"])
  {
    __destination = [[decoder decodeObjectForKey: @"destination"] retain_stub];
    __destination_isset = YES;
  }
  if ([decoder containsValueForKey: @"status"])
  {
    __status = [decoder decodeIntForKey: @"status"];
    __status_isset = YES;
  }
  if ([decoder containsValueForKey: @"courier"])
  {
    __courier = [[decoder decodeObjectForKey: @"courier"] retain_stub];
    __courier_isset = YES;
  }
  if ([decoder containsValueForKey: @"createdAt"])
  {
    __createdAt = [decoder decodeInt64ForKey: @"createdAt"];
    __createdAt_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__id_isset)
  {
    [encoder encodeObject: __id forKey: @"id"];
  }
  if (__origin_isset)
  {
    [encoder encodeObject: __origin forKey: @"origin"];
  }
  if (__destination_isset)
  {
    [encoder encodeObject: __destination forKey: @"destination"];
  }
  if (__status_isset)
  {
    [encoder encodeInt: __status forKey: @"status"];
  }
  if (__courier_isset)
  {
    [encoder encodeObject: __courier forKey: @"courier"];
  }
  if (__createdAt_isset)
  {
    [encoder encodeInt64: __createdAt forKey: @"createdAt"];
  }
}

- (void) dealloc
{
  [__id release_stub];
  [__origin release_stub];
  [__destination release_stub];
  [__courier release_stub];
  [super dealloc_stub];
}

- (NSString *) id {
  return [[__id retain_stub] autorelease_stub];
}

- (void) setId: (NSString *) id {
  [id retain_stub];
  [__id release_stub];
  __id = id;
  __id_isset = YES;
}

- (BOOL) idIsSet {
  return __id_isset;
}

- (void) unsetId {
  [__id release_stub];
  __id = nil;
  __id_isset = NO;
}

- (MDLatLng *) origin {
  return [[__origin retain_stub] autorelease_stub];
}

- (void) setOrigin: (MDLatLng *) origin {
  [origin retain_stub];
  [__origin release_stub];
  __origin = origin;
  __origin_isset = YES;
}

- (BOOL) originIsSet {
  return __origin_isset;
}

- (void) unsetOrigin {
  [__origin release_stub];
  __origin = nil;
  __origin_isset = NO;
}

- (MDLatLng *) destination {
  return [[__destination retain_stub] autorelease_stub];
}

- (void) setDestination: (MDLatLng *) destination {
  [destination retain_stub];
  [__destination release_stub];
  __destination = destination;
  __destination_isset = YES;
}

- (BOOL) destinationIsSet {
  return __destination_isset;
}

- (void) unsetDestination {
  [__destination release_stub];
  __destination = nil;
  __destination_isset = NO;
}

- (int) status {
  return __status;
}

- (void) setStatus: (int) status {
  __status = status;
  __status_isset = YES;
}

- (BOOL) statusIsSet {
  return __status_isset;
}

- (void) unsetStatus {
  __status_isset = NO;
}

- (MDCourier *) courier {
  return [[__courier retain_stub] autorelease_stub];
}

- (void) setCourier: (MDCourier *) courier {
  [courier retain_stub];
  [__courier release_stub];
  __courier = courier;
  __courier_isset = YES;
}

- (BOOL) courierIsSet {
  return __courier_isset;
}

- (void) unsetCourier {
  [__courier release_stub];
  __courier = nil;
  __courier_isset = NO;
}

- (int64_t) createdAt {
  return __createdAt;
}

- (void) setCreatedAt: (int64_t) createdAt {
  __createdAt = createdAt;
  __createdAt_isset = YES;
}

- (BOOL) createdAtIsSet {
  return __createdAt_isset;
}

- (void) unsetCreatedAt {
  __createdAt_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          MDLatLng *fieldValue = [[MDLatLng alloc] init];
          [fieldValue read: inProtocol];
          [self setOrigin: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          MDLatLng *fieldValue = [[MDLatLng alloc] init];
          [fieldValue read: inProtocol];
          [self setDestination: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setStatus: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRUCT) {
          MDCourier *fieldValue = [[MDCourier alloc] init];
          [fieldValue read: inProtocol];
          [self setCourier: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCreatedAt: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Delivery"];
  if (__id_isset) {
    if (__id != nil) {
      [outProtocol writeFieldBeginWithName: @"id" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __id];
      [outProtocol writeFieldEnd];
    }
  }
  if (__origin_isset) {
    if (__origin != nil) {
      [outProtocol writeFieldBeginWithName: @"origin" type: TType_STRUCT fieldID: 2];
      [__origin write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__destination_isset) {
    if (__destination != nil) {
      [outProtocol writeFieldBeginWithName: @"destination" type: TType_STRUCT fieldID: 3];
      [__destination write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__status_isset) {
    [outProtocol writeFieldBeginWithName: @"status" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __status];
    [outProtocol writeFieldEnd];
  }
  if (__courier_isset) {
    if (__courier != nil) {
      [outProtocol writeFieldBeginWithName: @"courier" type: TType_STRUCT fieldID: 5];
      [__courier write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__createdAt_isset) {
    [outProtocol writeFieldBeginWithName: @"createdAt" type: TType_I64 fieldID: 6];
    [outProtocol writeI64: __createdAt];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
  if (!__id_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'id' is not set."];
  }
  if (!__origin_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'origin' is not set."];
  }
  if (!__destination_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'destination' is not set."];
  }
  if (!__status_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'status' is not set."];
  }
  if (!__createdAt_isset) {
    @throw [TProtocolException exceptionWithName: @"TProtocolException"
                               reason: @"Required field 'createdAt' is not set."];
  }
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDDelivery("];
  [ms appendString: @"id:"];
  [ms appendFormat: @"\"%@\"", __id];
  [ms appendString: @",origin:"];
  [ms appendFormat: @"%@", __origin];
  [ms appendString: @",destination:"];
  [ms appendFormat: @"%@", __destination];
  [ms appendString: @",status:"];
  [ms appendFormat: @"%i", __status];
  [ms appendString: @",courier:"];
  [ms appendFormat: @"%@", __courier];
  [ms appendString: @",createdAt:"];
  [ms appendFormat: @"%qi", __createdAt];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation MDServiceException

- (id) init
{
  return [super initWithName: @"MDServiceException" reason: @"unknown" userInfo: nil];
}

- (id) initWithCode: (int) code parameter: (NSString *) parameter message: (NSString *) message
{
  self = [self init];
  __code = code;
  __code_isset = YES;
  __parameter = [parameter retain_stub];
  __parameter_isset = YES;
  __message = [message retain_stub];
  __message_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super initWithCoder: decoder];
  if ([decoder containsValueForKey: @"code"])
  {
    __code = [decoder decodeIntForKey: @"code"];
    __code_isset = YES;
  }
  if ([decoder containsValueForKey: @"parameter"])
  {
    __parameter = [[decoder decodeObjectForKey: @"parameter"] retain_stub];
    __parameter_isset = YES;
  }
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain_stub];
    __message_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  [super encodeWithCoder: encoder];
  if (__code_isset)
  {
    [encoder encodeInt: __code forKey: @"code"];
  }
  if (__parameter_isset)
  {
    [encoder encodeObject: __parameter forKey: @"parameter"];
  }
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
}

- (void) dealloc
{
  [__parameter release_stub];
  [__message release_stub];
  [super dealloc_stub];
}

- (int) code {
  return __code;
}

- (void) setCode: (int) code {
  __code = code;
  __code_isset = YES;
}

- (BOOL) codeIsSet {
  return __code_isset;
}

- (void) unsetCode {
  __code_isset = NO;
}

- (NSString *) parameter {
  return [[__parameter retain_stub] autorelease_stub];
}

- (void) setParameter: (NSString *) parameter {
  [parameter retain_stub];
  [__parameter release_stub];
  __parameter = parameter;
  __parameter_isset = YES;
}

- (BOOL) parameterIsSet {
  return __parameter_isset;
}

- (void) unsetParameter {
  [__parameter release_stub];
  __parameter = nil;
  __parameter_isset = NO;
}

- (NSString *) message {
  return [[__message retain_stub] autorelease_stub];
}

- (void) setMessage: (NSString *) message {
  [message retain_stub];
  [__message release_stub];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release_stub];
  __message = nil;
  __message_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int fieldValue = [inProtocol readI32];
          [self setCode: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setParameter: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ServiceException"];
  if (__code_isset) {
    [outProtocol writeFieldBeginWithName: @"code" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __code];
    [outProtocol writeFieldEnd];
  }
  if (__parameter_isset) {
    if (__parameter != nil) {
      [outProtocol writeFieldBeginWithName: @"parameter" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __parameter];
      [outProtocol writeFieldEnd];
    }
  }
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDServiceException("];
  [ms appendString: @"code:"];
  [ms appendFormat: @"%i", __code];
  [ms appendString: @",parameter:"];
  [ms appendFormat: @"\"%@\"", __parameter];
  [ms appendString: @",message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end


@implementation MDDeliveryConstants
+ (void) initialize {
}
@end

@interface MDsubmitDelivery_args : NSObject <TBase, NSCoding> {
  MDAccessToken __accessToken;
  MDDelivery * __delivery;

  BOOL __accessToken_isset;
  BOOL __delivery_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=accessToken, setter=setAccessToken:) MDAccessToken accessToken;
@property (nonatomic, retain, getter=delivery, setter=setDelivery:) MDDelivery * delivery;
#endif

- (id) init;
- (id) initWithAccessToken: (MDAccessToken) accessToken delivery: (MDDelivery *) delivery;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDAccessToken) accessToken;
- (void) setAccessToken: (MDAccessToken) accessToken;
#endif
- (BOOL) accessTokenIsSet;

#if !__has_feature(objc_arc)
- (MDDelivery *) delivery;
- (void) setDelivery: (MDDelivery *) delivery;
#endif
- (BOOL) deliveryIsSet;

@end

@implementation MDsubmitDelivery_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccessToken: (MDAccessToken) accessToken delivery: (MDDelivery *) delivery
{
  self = [super init];
  __accessToken = [accessToken retain_stub];
  __accessToken_isset = YES;
  __delivery = [delivery retain_stub];
  __delivery_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"accessToken"])
  {
    __accessToken = [[decoder decodeObjectForKey: @"accessToken"] retain_stub];
    __accessToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"delivery"])
  {
    __delivery = [[decoder decodeObjectForKey: @"delivery"] retain_stub];
    __delivery_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__accessToken_isset)
  {
    [encoder encodeObject: __accessToken forKey: @"accessToken"];
  }
  if (__delivery_isset)
  {
    [encoder encodeObject: __delivery forKey: @"delivery"];
  }
}

- (void) dealloc
{
  [__accessToken release_stub];
  [__delivery release_stub];
  [super dealloc_stub];
}

- (NSString *) accessToken {
  return [[__accessToken retain_stub] autorelease_stub];
}

- (void) setAccessToken: (NSString *) accessToken {
  [accessToken retain_stub];
  [__accessToken release_stub];
  __accessToken = accessToken;
  __accessToken_isset = YES;
}

- (BOOL) accessTokenIsSet {
  return __accessToken_isset;
}

- (void) unsetAccessToken {
  [__accessToken release_stub];
  __accessToken = nil;
  __accessToken_isset = NO;
}

- (MDDelivery *) delivery {
  return [[__delivery retain_stub] autorelease_stub];
}

- (void) setDelivery: (MDDelivery *) delivery {
  [delivery retain_stub];
  [__delivery release_stub];
  __delivery = delivery;
  __delivery_isset = YES;
}

- (BOOL) deliveryIsSet {
  return __delivery_isset;
}

- (void) unsetDelivery {
  [__delivery release_stub];
  __delivery = nil;
  __delivery_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAccessToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          MDDelivery *fieldValue = [[MDDelivery alloc] init];
          [fieldValue read: inProtocol];
          [self setDelivery: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"submitDelivery_args"];
  if (__accessToken_isset) {
    if (__accessToken != nil) {
      [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __accessToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__delivery_isset) {
    if (__delivery != nil) {
      [outProtocol writeFieldBeginWithName: @"delivery" type: TType_STRUCT fieldID: 2];
      [__delivery write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDsubmitDelivery_args("];
  [ms appendString: @"accessToken:"];
  [ms appendFormat: @"\"%@\"", __accessToken];
  [ms appendString: @",delivery:"];
  [ms appendFormat: @"%@", __delivery];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDSubmitDelivery_result : NSObject <TBase, NSCoding> {
  MDDelivery * __success;
  MDServiceException * __e;

  BOOL __success_isset;
  BOOL __e_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) MDDelivery * success;
@property (nonatomic, retain, getter=e, setter=setE:) MDServiceException * e;
#endif

- (id) init;
- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDDelivery *) success;
- (void) setSuccess: (MDDelivery *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (MDServiceException *) e;
- (void) setE: (MDServiceException *) e;
#endif
- (BOOL) eIsSet;

@end

@implementation MDSubmitDelivery_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __e = [e retain_stub];
  __e_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"e"])
  {
    __e = [[decoder decodeObjectForKey: @"e"] retain_stub];
    __e_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__e_isset)
  {
    [encoder encodeObject: __e forKey: @"e"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__e release_stub];
  [super dealloc_stub];
}

- (MDDelivery *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (MDDelivery *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (MDServiceException *) e {
  return [[__e retain_stub] autorelease_stub];
}

- (void) setE: (MDServiceException *) e {
  [e retain_stub];
  [__e release_stub];
  __e = e;
  __e_isset = YES;
}

- (BOOL) eIsSet {
  return __e_isset;
}

- (void) unsetE {
  [__e release_stub];
  __e = nil;
  __e_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          MDDelivery *fieldValue = [[MDDelivery alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          MDServiceException *fieldValue = [[MDServiceException alloc] init];
          [fieldValue read: inProtocol];
          [self setE: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SubmitDelivery_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__e_isset) {
    if (__e != nil) {
      [outProtocol writeFieldBeginWithName: @"e" type: TType_STRUCT fieldID: 1];
      [__e write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDSubmitDelivery_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",e:"];
  [ms appendFormat: @"%@", __e];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDgetDelivery_args : NSObject <TBase, NSCoding> {
  MDAccessToken __accessToken;
  int32_t __deliveryId;

  BOOL __accessToken_isset;
  BOOL __deliveryId_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=accessToken, setter=setAccessToken:) MDAccessToken accessToken;
@property (nonatomic, getter=deliveryId, setter=setDeliveryId:) int32_t deliveryId;
#endif

- (id) init;
- (id) initWithAccessToken: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDAccessToken) accessToken;
- (void) setAccessToken: (MDAccessToken) accessToken;
#endif
- (BOOL) accessTokenIsSet;

#if !__has_feature(objc_arc)
- (int32_t) deliveryId;
- (void) setDeliveryId: (int32_t) deliveryId;
#endif
- (BOOL) deliveryIdIsSet;

@end

@implementation MDgetDelivery_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccessToken: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  self = [super init];
  __accessToken = [accessToken retain_stub];
  __accessToken_isset = YES;
  __deliveryId = deliveryId;
  __deliveryId_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"accessToken"])
  {
    __accessToken = [[decoder decodeObjectForKey: @"accessToken"] retain_stub];
    __accessToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"deliveryId"])
  {
    __deliveryId = [decoder decodeInt32ForKey: @"deliveryId"];
    __deliveryId_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__accessToken_isset)
  {
    [encoder encodeObject: __accessToken forKey: @"accessToken"];
  }
  if (__deliveryId_isset)
  {
    [encoder encodeInt32: __deliveryId forKey: @"deliveryId"];
  }
}

- (void) dealloc
{
  [__accessToken release_stub];
  [super dealloc_stub];
}

- (NSString *) accessToken {
  return [[__accessToken retain_stub] autorelease_stub];
}

- (void) setAccessToken: (NSString *) accessToken {
  [accessToken retain_stub];
  [__accessToken release_stub];
  __accessToken = accessToken;
  __accessToken_isset = YES;
}

- (BOOL) accessTokenIsSet {
  return __accessToken_isset;
}

- (void) unsetAccessToken {
  [__accessToken release_stub];
  __accessToken = nil;
  __accessToken_isset = NO;
}

- (int32_t) deliveryId {
  return __deliveryId;
}

- (void) setDeliveryId: (int32_t) deliveryId {
  __deliveryId = deliveryId;
  __deliveryId_isset = YES;
}

- (BOOL) deliveryIdIsSet {
  return __deliveryId_isset;
}

- (void) unsetDeliveryId {
  __deliveryId_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAccessToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setDeliveryId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getDelivery_args"];
  if (__accessToken_isset) {
    if (__accessToken != nil) {
      [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __accessToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__deliveryId_isset) {
    [outProtocol writeFieldBeginWithName: @"deliveryId" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __deliveryId];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDgetDelivery_args("];
  [ms appendString: @"accessToken:"];
  [ms appendFormat: @"\"%@\"", __accessToken];
  [ms appendString: @",deliveryId:"];
  [ms appendFormat: @"%i", __deliveryId];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDGetDelivery_result : NSObject <TBase, NSCoding> {
  MDDelivery * __success;
  MDServiceException * __e;

  BOOL __success_isset;
  BOOL __e_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) MDDelivery * success;
@property (nonatomic, retain, getter=e, setter=setE:) MDServiceException * e;
#endif

- (id) init;
- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDDelivery *) success;
- (void) setSuccess: (MDDelivery *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (MDServiceException *) e;
- (void) setE: (MDServiceException *) e;
#endif
- (BOOL) eIsSet;

@end

@implementation MDGetDelivery_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __e = [e retain_stub];
  __e_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"e"])
  {
    __e = [[decoder decodeObjectForKey: @"e"] retain_stub];
    __e_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__e_isset)
  {
    [encoder encodeObject: __e forKey: @"e"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__e release_stub];
  [super dealloc_stub];
}

- (MDDelivery *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (MDDelivery *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (MDServiceException *) e {
  return [[__e retain_stub] autorelease_stub];
}

- (void) setE: (MDServiceException *) e {
  [e retain_stub];
  [__e release_stub];
  __e = e;
  __e_isset = YES;
}

- (BOOL) eIsSet {
  return __e_isset;
}

- (void) unsetE {
  [__e release_stub];
  __e = nil;
  __e_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          MDDelivery *fieldValue = [[MDDelivery alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          MDServiceException *fieldValue = [[MDServiceException alloc] init];
          [fieldValue read: inProtocol];
          [self setE: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetDelivery_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__e_isset) {
    if (__e != nil) {
      [outProtocol writeFieldBeginWithName: @"e" type: TType_STRUCT fieldID: 1];
      [__e write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDGetDelivery_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",e:"];
  [ms appendFormat: @"%@", __e];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDlistDeliveries_args : NSObject <TBase, NSCoding> {
  MDAccessToken __accessToken;
  int32_t __offset;
  int32_t __limit;

  BOOL __accessToken_isset;
  BOOL __offset_isset;
  BOOL __limit_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=accessToken, setter=setAccessToken:) MDAccessToken accessToken;
@property (nonatomic, getter=offset, setter=setOffset:) int32_t offset;
@property (nonatomic, getter=limit, setter=setLimit:) int32_t limit;
#endif

- (id) init;
- (id) initWithAccessToken: (MDAccessToken) accessToken offset: (int32_t) offset limit: (int32_t) limit;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDAccessToken) accessToken;
- (void) setAccessToken: (MDAccessToken) accessToken;
#endif
- (BOOL) accessTokenIsSet;

#if !__has_feature(objc_arc)
- (int32_t) offset;
- (void) setOffset: (int32_t) offset;
#endif
- (BOOL) offsetIsSet;

#if !__has_feature(objc_arc)
- (int32_t) limit;
- (void) setLimit: (int32_t) limit;
#endif
- (BOOL) limitIsSet;

@end

@implementation MDlistDeliveries_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccessToken: (MDAccessToken) accessToken offset: (int32_t) offset limit: (int32_t) limit
{
  self = [super init];
  __accessToken = [accessToken retain_stub];
  __accessToken_isset = YES;
  __offset = offset;
  __offset_isset = YES;
  __limit = limit;
  __limit_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"accessToken"])
  {
    __accessToken = [[decoder decodeObjectForKey: @"accessToken"] retain_stub];
    __accessToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"offset"])
  {
    __offset = [decoder decodeInt32ForKey: @"offset"];
    __offset_isset = YES;
  }
  if ([decoder containsValueForKey: @"limit"])
  {
    __limit = [decoder decodeInt32ForKey: @"limit"];
    __limit_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__accessToken_isset)
  {
    [encoder encodeObject: __accessToken forKey: @"accessToken"];
  }
  if (__offset_isset)
  {
    [encoder encodeInt32: __offset forKey: @"offset"];
  }
  if (__limit_isset)
  {
    [encoder encodeInt32: __limit forKey: @"limit"];
  }
}

- (void) dealloc
{
  [__accessToken release_stub];
  [super dealloc_stub];
}

- (NSString *) accessToken {
  return [[__accessToken retain_stub] autorelease_stub];
}

- (void) setAccessToken: (NSString *) accessToken {
  [accessToken retain_stub];
  [__accessToken release_stub];
  __accessToken = accessToken;
  __accessToken_isset = YES;
}

- (BOOL) accessTokenIsSet {
  return __accessToken_isset;
}

- (void) unsetAccessToken {
  [__accessToken release_stub];
  __accessToken = nil;
  __accessToken_isset = NO;
}

- (int32_t) offset {
  return __offset;
}

- (void) setOffset: (int32_t) offset {
  __offset = offset;
  __offset_isset = YES;
}

- (BOOL) offsetIsSet {
  return __offset_isset;
}

- (void) unsetOffset {
  __offset_isset = NO;
}

- (int32_t) limit {
  return __limit;
}

- (void) setLimit: (int32_t) limit {
  __limit = limit;
  __limit_isset = YES;
}

- (BOOL) limitIsSet {
  return __limit_isset;
}

- (void) unsetLimit {
  __limit_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAccessToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOffset: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setLimit: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listDeliveries_args"];
  if (__accessToken_isset) {
    if (__accessToken != nil) {
      [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __accessToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__offset_isset) {
    [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __offset];
    [outProtocol writeFieldEnd];
  }
  if (__limit_isset) {
    [outProtocol writeFieldBeginWithName: @"limit" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __limit];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDlistDeliveries_args("];
  [ms appendString: @"accessToken:"];
  [ms appendFormat: @"\"%@\"", __accessToken];
  [ms appendString: @",offset:"];
  [ms appendFormat: @"%i", __offset];
  [ms appendString: @",limit:"];
  [ms appendFormat: @"%i", __limit];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDListDeliveries_result : NSObject <TBase, NSCoding> {
  NSMutableArray * __success;
  MDServiceException * __e;

  BOOL __success_isset;
  BOOL __e_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSMutableArray * success;
@property (nonatomic, retain, getter=e, setter=setE:) MDServiceException * e;
#endif

- (id) init;
- (id) initWithSuccess: (NSMutableArray *) success e: (MDServiceException *) e;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (NSMutableArray *) success;
- (void) setSuccess: (NSMutableArray *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (MDServiceException *) e;
- (void) setE: (MDServiceException *) e;
#endif
- (BOOL) eIsSet;

@end

@implementation MDListDeliveries_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (NSMutableArray *) success e: (MDServiceException *) e
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __e = [e retain_stub];
  __e_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"e"])
  {
    __e = [[decoder decodeObjectForKey: @"e"] retain_stub];
    __e_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__e_isset)
  {
    [encoder encodeObject: __e forKey: @"e"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__e release_stub];
  [super dealloc_stub];
}

- (NSMutableArray *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (NSMutableArray *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (MDServiceException *) e {
  return [[__e retain_stub] autorelease_stub];
}

- (void) setE: (MDServiceException *) e {
  [e retain_stub];
  [__e release_stub];
  __e = e;
  __e_isset = YES;
}

- (BOOL) eIsSet {
  return __e_isset;
}

- (void) unsetE {
  [__e release_stub];
  __e = nil;
  __e_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            MDDelivery *_elem2 = [[MDDelivery alloc] init];
            [_elem2 read: inProtocol];
            [fieldValue addObject: _elem2];
            [_elem2 release_stub];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          MDServiceException *fieldValue = [[MDServiceException alloc] init];
          [fieldValue read: inProtocol];
          [self setE: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListDeliveries_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i4;
        for (i4 = 0; i4 < [__success count]; i4++)
        {
          [[__success objectAtIndex: i4] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__e_isset) {
    if (__e != nil) {
      [outProtocol writeFieldBeginWithName: @"e" type: TType_STRUCT fieldID: 1];
      [__e write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDListDeliveries_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",e:"];
  [ms appendFormat: @"%@", __e];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDassignCourier_args : NSObject <TBase, NSCoding> {
  MDAccessToken __accessToken;
  int32_t __deliveryId;
  int32_t __courierId;

  BOOL __accessToken_isset;
  BOOL __deliveryId_isset;
  BOOL __courierId_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=accessToken, setter=setAccessToken:) MDAccessToken accessToken;
@property (nonatomic, getter=deliveryId, setter=setDeliveryId:) int32_t deliveryId;
@property (nonatomic, getter=courierId, setter=setCourierId:) int32_t courierId;
#endif

- (id) init;
- (id) initWithAccessToken: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId courierId: (int32_t) courierId;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDAccessToken) accessToken;
- (void) setAccessToken: (MDAccessToken) accessToken;
#endif
- (BOOL) accessTokenIsSet;

#if !__has_feature(objc_arc)
- (int32_t) deliveryId;
- (void) setDeliveryId: (int32_t) deliveryId;
#endif
- (BOOL) deliveryIdIsSet;

#if !__has_feature(objc_arc)
- (int32_t) courierId;
- (void) setCourierId: (int32_t) courierId;
#endif
- (BOOL) courierIdIsSet;

@end

@implementation MDassignCourier_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccessToken: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId courierId: (int32_t) courierId
{
  self = [super init];
  __accessToken = [accessToken retain_stub];
  __accessToken_isset = YES;
  __deliveryId = deliveryId;
  __deliveryId_isset = YES;
  __courierId = courierId;
  __courierId_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"accessToken"])
  {
    __accessToken = [[decoder decodeObjectForKey: @"accessToken"] retain_stub];
    __accessToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"deliveryId"])
  {
    __deliveryId = [decoder decodeInt32ForKey: @"deliveryId"];
    __deliveryId_isset = YES;
  }
  if ([decoder containsValueForKey: @"courierId"])
  {
    __courierId = [decoder decodeInt32ForKey: @"courierId"];
    __courierId_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__accessToken_isset)
  {
    [encoder encodeObject: __accessToken forKey: @"accessToken"];
  }
  if (__deliveryId_isset)
  {
    [encoder encodeInt32: __deliveryId forKey: @"deliveryId"];
  }
  if (__courierId_isset)
  {
    [encoder encodeInt32: __courierId forKey: @"courierId"];
  }
}

- (void) dealloc
{
  [__accessToken release_stub];
  [super dealloc_stub];
}

- (NSString *) accessToken {
  return [[__accessToken retain_stub] autorelease_stub];
}

- (void) setAccessToken: (NSString *) accessToken {
  [accessToken retain_stub];
  [__accessToken release_stub];
  __accessToken = accessToken;
  __accessToken_isset = YES;
}

- (BOOL) accessTokenIsSet {
  return __accessToken_isset;
}

- (void) unsetAccessToken {
  [__accessToken release_stub];
  __accessToken = nil;
  __accessToken_isset = NO;
}

- (int32_t) deliveryId {
  return __deliveryId;
}

- (void) setDeliveryId: (int32_t) deliveryId {
  __deliveryId = deliveryId;
  __deliveryId_isset = YES;
}

- (BOOL) deliveryIdIsSet {
  return __deliveryId_isset;
}

- (void) unsetDeliveryId {
  __deliveryId_isset = NO;
}

- (int32_t) courierId {
  return __courierId;
}

- (void) setCourierId: (int32_t) courierId {
  __courierId = courierId;
  __courierId_isset = YES;
}

- (BOOL) courierIdIsSet {
  return __courierId_isset;
}

- (void) unsetCourierId {
  __courierId_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAccessToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setDeliveryId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setCourierId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"assignCourier_args"];
  if (__accessToken_isset) {
    if (__accessToken != nil) {
      [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __accessToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__deliveryId_isset) {
    [outProtocol writeFieldBeginWithName: @"deliveryId" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __deliveryId];
    [outProtocol writeFieldEnd];
  }
  if (__courierId_isset) {
    [outProtocol writeFieldBeginWithName: @"courierId" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __courierId];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDassignCourier_args("];
  [ms appendString: @"accessToken:"];
  [ms appendFormat: @"\"%@\"", __accessToken];
  [ms appendString: @",deliveryId:"];
  [ms appendFormat: @"%i", __deliveryId];
  [ms appendString: @",courierId:"];
  [ms appendFormat: @"%i", __courierId];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDAssignCourier_result : NSObject <TBase, NSCoding> {
  MDDelivery * __success;
  MDServiceException * __e;

  BOOL __success_isset;
  BOOL __e_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) MDDelivery * success;
@property (nonatomic, retain, getter=e, setter=setE:) MDServiceException * e;
#endif

- (id) init;
- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDDelivery *) success;
- (void) setSuccess: (MDDelivery *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (MDServiceException *) e;
- (void) setE: (MDServiceException *) e;
#endif
- (BOOL) eIsSet;

@end

@implementation MDAssignCourier_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __e = [e retain_stub];
  __e_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"e"])
  {
    __e = [[decoder decodeObjectForKey: @"e"] retain_stub];
    __e_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__e_isset)
  {
    [encoder encodeObject: __e forKey: @"e"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__e release_stub];
  [super dealloc_stub];
}

- (MDDelivery *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (MDDelivery *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (MDServiceException *) e {
  return [[__e retain_stub] autorelease_stub];
}

- (void) setE: (MDServiceException *) e {
  [e retain_stub];
  [__e release_stub];
  __e = e;
  __e_isset = YES;
}

- (BOOL) eIsSet {
  return __e_isset;
}

- (void) unsetE {
  [__e release_stub];
  __e = nil;
  __e_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          MDDelivery *fieldValue = [[MDDelivery alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          MDServiceException *fieldValue = [[MDServiceException alloc] init];
          [fieldValue read: inProtocol];
          [self setE: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AssignCourier_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__e_isset) {
    if (__e != nil) {
      [outProtocol writeFieldBeginWithName: @"e" type: TType_STRUCT fieldID: 1];
      [__e write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDAssignCourier_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",e:"];
  [ms appendFormat: @"%@", __e];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDcancelDelivery_args : NSObject <TBase, NSCoding> {
  MDAccessToken __accessToken;
  int32_t __deliveryId;

  BOOL __accessToken_isset;
  BOOL __deliveryId_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=accessToken, setter=setAccessToken:) MDAccessToken accessToken;
@property (nonatomic, getter=deliveryId, setter=setDeliveryId:) int32_t deliveryId;
#endif

- (id) init;
- (id) initWithAccessToken: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDAccessToken) accessToken;
- (void) setAccessToken: (MDAccessToken) accessToken;
#endif
- (BOOL) accessTokenIsSet;

#if !__has_feature(objc_arc)
- (int32_t) deliveryId;
- (void) setDeliveryId: (int32_t) deliveryId;
#endif
- (BOOL) deliveryIdIsSet;

@end

@implementation MDcancelDelivery_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccessToken: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  self = [super init];
  __accessToken = [accessToken retain_stub];
  __accessToken_isset = YES;
  __deliveryId = deliveryId;
  __deliveryId_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"accessToken"])
  {
    __accessToken = [[decoder decodeObjectForKey: @"accessToken"] retain_stub];
    __accessToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"deliveryId"])
  {
    __deliveryId = [decoder decodeInt32ForKey: @"deliveryId"];
    __deliveryId_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__accessToken_isset)
  {
    [encoder encodeObject: __accessToken forKey: @"accessToken"];
  }
  if (__deliveryId_isset)
  {
    [encoder encodeInt32: __deliveryId forKey: @"deliveryId"];
  }
}

- (void) dealloc
{
  [__accessToken release_stub];
  [super dealloc_stub];
}

- (NSString *) accessToken {
  return [[__accessToken retain_stub] autorelease_stub];
}

- (void) setAccessToken: (NSString *) accessToken {
  [accessToken retain_stub];
  [__accessToken release_stub];
  __accessToken = accessToken;
  __accessToken_isset = YES;
}

- (BOOL) accessTokenIsSet {
  return __accessToken_isset;
}

- (void) unsetAccessToken {
  [__accessToken release_stub];
  __accessToken = nil;
  __accessToken_isset = NO;
}

- (int32_t) deliveryId {
  return __deliveryId;
}

- (void) setDeliveryId: (int32_t) deliveryId {
  __deliveryId = deliveryId;
  __deliveryId_isset = YES;
}

- (BOOL) deliveryIdIsSet {
  return __deliveryId_isset;
}

- (void) unsetDeliveryId {
  __deliveryId_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAccessToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setDeliveryId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"cancelDelivery_args"];
  if (__accessToken_isset) {
    if (__accessToken != nil) {
      [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __accessToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__deliveryId_isset) {
    [outProtocol writeFieldBeginWithName: @"deliveryId" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __deliveryId];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDcancelDelivery_args("];
  [ms appendString: @"accessToken:"];
  [ms appendFormat: @"\"%@\"", __accessToken];
  [ms appendString: @",deliveryId:"];
  [ms appendFormat: @"%i", __deliveryId];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDCancelDelivery_result : NSObject <TBase, NSCoding> {
  MDDelivery * __success;
  MDServiceException * __e;

  BOOL __success_isset;
  BOOL __e_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) MDDelivery * success;
@property (nonatomic, retain, getter=e, setter=setE:) MDServiceException * e;
#endif

- (id) init;
- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDDelivery *) success;
- (void) setSuccess: (MDDelivery *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (MDServiceException *) e;
- (void) setE: (MDServiceException *) e;
#endif
- (BOOL) eIsSet;

@end

@implementation MDCancelDelivery_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __e = [e retain_stub];
  __e_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"e"])
  {
    __e = [[decoder decodeObjectForKey: @"e"] retain_stub];
    __e_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__e_isset)
  {
    [encoder encodeObject: __e forKey: @"e"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__e release_stub];
  [super dealloc_stub];
}

- (MDDelivery *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (MDDelivery *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (MDServiceException *) e {
  return [[__e retain_stub] autorelease_stub];
}

- (void) setE: (MDServiceException *) e {
  [e retain_stub];
  [__e release_stub];
  __e = e;
  __e_isset = YES;
}

- (BOOL) eIsSet {
  return __e_isset;
}

- (void) unsetE {
  [__e release_stub];
  __e = nil;
  __e_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          MDDelivery *fieldValue = [[MDDelivery alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          MDServiceException *fieldValue = [[MDServiceException alloc] init];
          [fieldValue read: inProtocol];
          [self setE: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CancelDelivery_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__e_isset) {
    if (__e != nil) {
      [outProtocol writeFieldBeginWithName: @"e" type: TType_STRUCT fieldID: 1];
      [__e write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDCancelDelivery_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",e:"];
  [ms appendFormat: @"%@", __e];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDcompleteDelivery_args : NSObject <TBase, NSCoding> {
  MDAccessToken __accessToken;
  int32_t __deliveryId;

  BOOL __accessToken_isset;
  BOOL __deliveryId_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=accessToken, setter=setAccessToken:) MDAccessToken accessToken;
@property (nonatomic, getter=deliveryId, setter=setDeliveryId:) int32_t deliveryId;
#endif

- (id) init;
- (id) initWithAccessToken: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDAccessToken) accessToken;
- (void) setAccessToken: (MDAccessToken) accessToken;
#endif
- (BOOL) accessTokenIsSet;

#if !__has_feature(objc_arc)
- (int32_t) deliveryId;
- (void) setDeliveryId: (int32_t) deliveryId;
#endif
- (BOOL) deliveryIdIsSet;

@end

@implementation MDcompleteDelivery_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAccessToken: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  self = [super init];
  __accessToken = [accessToken retain_stub];
  __accessToken_isset = YES;
  __deliveryId = deliveryId;
  __deliveryId_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"accessToken"])
  {
    __accessToken = [[decoder decodeObjectForKey: @"accessToken"] retain_stub];
    __accessToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"deliveryId"])
  {
    __deliveryId = [decoder decodeInt32ForKey: @"deliveryId"];
    __deliveryId_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__accessToken_isset)
  {
    [encoder encodeObject: __accessToken forKey: @"accessToken"];
  }
  if (__deliveryId_isset)
  {
    [encoder encodeInt32: __deliveryId forKey: @"deliveryId"];
  }
}

- (void) dealloc
{
  [__accessToken release_stub];
  [super dealloc_stub];
}

- (NSString *) accessToken {
  return [[__accessToken retain_stub] autorelease_stub];
}

- (void) setAccessToken: (NSString *) accessToken {
  [accessToken retain_stub];
  [__accessToken release_stub];
  __accessToken = accessToken;
  __accessToken_isset = YES;
}

- (BOOL) accessTokenIsSet {
  return __accessToken_isset;
}

- (void) unsetAccessToken {
  [__accessToken release_stub];
  __accessToken = nil;
  __accessToken_isset = NO;
}

- (int32_t) deliveryId {
  return __deliveryId;
}

- (void) setDeliveryId: (int32_t) deliveryId {
  __deliveryId = deliveryId;
  __deliveryId_isset = YES;
}

- (BOOL) deliveryIdIsSet {
  return __deliveryId_isset;
}

- (void) unsetDeliveryId {
  __deliveryId_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAccessToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setDeliveryId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"completeDelivery_args"];
  if (__accessToken_isset) {
    if (__accessToken != nil) {
      [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __accessToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__deliveryId_isset) {
    [outProtocol writeFieldBeginWithName: @"deliveryId" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __deliveryId];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDcompleteDelivery_args("];
  [ms appendString: @"accessToken:"];
  [ms appendFormat: @"\"%@\"", __accessToken];
  [ms appendString: @",deliveryId:"];
  [ms appendFormat: @"%i", __deliveryId];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface MDCompleteDelivery_result : NSObject <TBase, NSCoding> {
  MDDelivery * __success;
  MDServiceException * __e;

  BOOL __success_isset;
  BOOL __e_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) MDDelivery * success;
@property (nonatomic, retain, getter=e, setter=setE:) MDServiceException * e;
#endif

- (id) init;
- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (MDDelivery *) success;
- (void) setSuccess: (MDDelivery *) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (MDServiceException *) e;
- (void) setE: (MDServiceException *) e;
#endif
- (BOOL) eIsSet;

@end

@implementation MDCompleteDelivery_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (MDDelivery *) success e: (MDServiceException *) e
{
  self = [super init];
  __success = [success retain_stub];
  __success_isset = YES;
  __e = [e retain_stub];
  __e_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain_stub];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"e"])
  {
    __e = [[decoder decodeObjectForKey: @"e"] retain_stub];
    __e_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__e_isset)
  {
    [encoder encodeObject: __e forKey: @"e"];
  }
}

- (void) dealloc
{
  [__success release_stub];
  [__e release_stub];
  [super dealloc_stub];
}

- (MDDelivery *) success {
  return [[__success retain_stub] autorelease_stub];
}

- (void) setSuccess: (MDDelivery *) success {
  [success retain_stub];
  [__success release_stub];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release_stub];
  __success = nil;
  __success_isset = NO;
}

- (MDServiceException *) e {
  return [[__e retain_stub] autorelease_stub];
}

- (void) setE: (MDServiceException *) e {
  [e retain_stub];
  [__e release_stub];
  __e = e;
  __e_isset = YES;
}

- (BOOL) eIsSet {
  return __e_isset;
}

- (void) unsetE {
  [__e release_stub];
  __e = nil;
  __e_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          MDDelivery *fieldValue = [[MDDelivery alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          MDServiceException *fieldValue = [[MDServiceException alloc] init];
          [fieldValue read: inProtocol];
          [self setE: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CompleteDelivery_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__e_isset) {
    if (__e != nil) {
      [outProtocol writeFieldBeginWithName: @"e" type: TType_STRUCT fieldID: 1];
      [__e write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"MDCompleteDelivery_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",e:"];
  [ms appendFormat: @"%@", __e];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation MDDeliveryServiceClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  inProtocol = [anInProtocol retain_stub];
  outProtocol = [anOutProtocol retain_stub];
  return self;
}

- (void) dealloc
{
  [inProtocol release_stub];
  [outProtocol release_stub];
  [super dealloc_stub];
}

- (void) send_submitDelivery: (MDAccessToken) accessToken delivery: (MDDelivery *) delivery
{
  [outProtocol writeMessageBeginWithName: @"submitDelivery" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"submitDelivery_args"];
  if (accessToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: accessToken];
    [outProtocol writeFieldEnd];
  }
  if (delivery != nil)  {
    [outProtocol writeFieldBeginWithName: @"delivery" type: TType_STRUCT fieldID: 2];
    [delivery write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (MDDelivery *) recv_submitDelivery
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  MDSubmitDelivery_result * result = [[[MDSubmitDelivery_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result eIsSet]) {
    @throw [result e];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"submitDelivery failed: unknown result"];
}

- (MDDelivery *) submitDelivery: (MDAccessToken) accessToken delivery: (MDDelivery *) delivery
{
  [self send_submitDelivery : accessToken delivery: delivery];
  return [self recv_submitDelivery];
}

- (void) send_getDelivery: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  [outProtocol writeMessageBeginWithName: @"getDelivery" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getDelivery_args"];
  if (accessToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: accessToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"deliveryId" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: deliveryId];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (MDDelivery *) recv_getDelivery
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  MDGetDelivery_result * result = [[[MDGetDelivery_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result eIsSet]) {
    @throw [result e];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getDelivery failed: unknown result"];
}

- (MDDelivery *) getDelivery: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  [self send_getDelivery : accessToken deliveryId: deliveryId];
  return [self recv_getDelivery];
}

- (void) send_listDeliveries: (MDAccessToken) accessToken offset: (int32_t) offset limit: (int32_t) limit
{
  [outProtocol writeMessageBeginWithName: @"listDeliveries" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listDeliveries_args"];
  if (accessToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: accessToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: offset];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"limit" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: limit];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSMutableArray *) recv_listDeliveries
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  MDListDeliveries_result * result = [[[MDListDeliveries_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result eIsSet]) {
    @throw [result e];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listDeliveries failed: unknown result"];
}

- (NSMutableArray *) listDeliveries: (MDAccessToken) accessToken offset: (int32_t) offset limit: (int32_t) limit
{
  [self send_listDeliveries : accessToken offset: offset limit: limit];
  return [self recv_listDeliveries];
}

- (void) send_assignCourier: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId courierId: (int32_t) courierId
{
  [outProtocol writeMessageBeginWithName: @"assignCourier" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"assignCourier_args"];
  if (accessToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: accessToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"deliveryId" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: deliveryId];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"courierId" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: courierId];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (MDDelivery *) recv_assignCourier
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  MDAssignCourier_result * result = [[[MDAssignCourier_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result eIsSet]) {
    @throw [result e];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"assignCourier failed: unknown result"];
}

- (MDDelivery *) assignCourier: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId courierId: (int32_t) courierId
{
  [self send_assignCourier : accessToken deliveryId: deliveryId courierId: courierId];
  return [self recv_assignCourier];
}

- (void) send_cancelDelivery: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  [outProtocol writeMessageBeginWithName: @"cancelDelivery" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"cancelDelivery_args"];
  if (accessToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: accessToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"deliveryId" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: deliveryId];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (MDDelivery *) recv_cancelDelivery
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  MDCancelDelivery_result * result = [[[MDCancelDelivery_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result eIsSet]) {
    @throw [result e];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"cancelDelivery failed: unknown result"];
}

- (MDDelivery *) cancelDelivery: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  [self send_cancelDelivery : accessToken deliveryId: deliveryId];
  return [self recv_cancelDelivery];
}

- (void) send_completeDelivery: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  [outProtocol writeMessageBeginWithName: @"completeDelivery" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"completeDelivery_args"];
  if (accessToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"accessToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: accessToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"deliveryId" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: deliveryId];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (MDDelivery *) recv_completeDelivery
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  MDCompleteDelivery_result * result = [[[MDCompleteDelivery_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result eIsSet]) {
    @throw [result e];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"completeDelivery failed: unknown result"];
}

- (MDDelivery *) completeDelivery: (MDAccessToken) accessToken deliveryId: (int32_t) deliveryId
{
  [self send_completeDelivery : accessToken deliveryId: deliveryId];
  return [self recv_completeDelivery];
}

@end

@implementation MDDeliveryServiceProcessor

- (id) initWithDeliveryService: (id <MDDeliveryService>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain_stub];
  mMethodMap = [[NSMutableDictionary dictionary] retain_stub];
  {
    SEL s = @selector(process_submitDelivery_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"submitDelivery"];
  }
  {
    SEL s = @selector(process_getDelivery_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getDelivery"];
  }
  {
    SEL s = @selector(process_listDeliveries_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listDeliveries"];
  }
  {
    SEL s = @selector(process_assignCourier_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"assignCourier"];
  }
  {
    SEL s = @selector(process_cancelDelivery_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"cancelDelivery"];
  }
  {
    SEL s = @selector(process_completeDelivery_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"completeDelivery"];
  }
  return self;
}

- (id<MDDeliveryService>) service
{
  return [[mService retain_stub] autorelease_stub];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_submitDelivery_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  MDsubmitDelivery_args * args = [[MDsubmitDelivery_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  MDSubmitDelivery_result * result = [[MDSubmitDelivery_result alloc] init];
  [result setSuccess: [mService submitDelivery: [args accessToken] delivery: [args delivery]]];
  [outProtocol writeMessageBeginWithName: @"submitDelivery"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_getDelivery_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  MDgetDelivery_args * args = [[MDgetDelivery_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  MDGetDelivery_result * result = [[MDGetDelivery_result alloc] init];
  [result setSuccess: [mService getDelivery: [args accessToken] deliveryId: [args deliveryId]]];
  [outProtocol writeMessageBeginWithName: @"getDelivery"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_listDeliveries_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  MDlistDeliveries_args * args = [[MDlistDeliveries_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  MDListDeliveries_result * result = [[MDListDeliveries_result alloc] init];
  [result setSuccess: [mService listDeliveries: [args accessToken] offset: [args offset] limit: [args limit]]];
  [outProtocol writeMessageBeginWithName: @"listDeliveries"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_assignCourier_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  MDassignCourier_args * args = [[MDassignCourier_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  MDAssignCourier_result * result = [[MDAssignCourier_result alloc] init];
  [result setSuccess: [mService assignCourier: [args accessToken] deliveryId: [args deliveryId] courierId: [args courierId]]];
  [outProtocol writeMessageBeginWithName: @"assignCourier"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_cancelDelivery_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  MDcancelDelivery_args * args = [[MDcancelDelivery_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  MDCancelDelivery_result * result = [[MDCancelDelivery_result alloc] init];
  [result setSuccess: [mService cancelDelivery: [args accessToken] deliveryId: [args deliveryId]]];
  [outProtocol writeMessageBeginWithName: @"cancelDelivery"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) process_completeDelivery_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  MDcompleteDelivery_args * args = [[MDcompleteDelivery_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  MDCompleteDelivery_result * result = [[MDCompleteDelivery_result alloc] init];
  [result setSuccess: [mService completeDelivery: [args accessToken] deliveryId: [args deliveryId]]];
  [outProtocol writeMessageBeginWithName: @"completeDelivery"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) dealloc
{
  [mService release_stub];
  [mMethodMap release_stub];
  [super dealloc_stub];
}

@end

